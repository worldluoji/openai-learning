# save load and rollback
Ren'Py has support for saving game state, loading game state, and rolling back to a previous game state.


Ren'Py attempts to save the game state. This includes both <strong>internal state</strong> and <strong>Python state</strong>.


The internal state consists of all aspects of Ren'Py that are intented to change once the game has started, and includes:
- The current statement, and all statements that can be returned to.
- The images and displayables that are being shown.
- The screens being shown, and the values of variables within those screens.
- The music that Ren'Py is playing.
- The list of nvl-mode text blocks.


The Python state consists of <strong>the variables in the store that have changed since the game began</strong>, 
and all objects reachable from those variables. 

Note that it's the change to the variables that matters – changes to fields in objects will not cause those objects to be saved.


Variables set using the <strong>default statement</strong> will always be saved.

In this example:
```
define a = 1
define o = object()
default c = 17

label start:
    $ b = 1
    $ o.value = 42
```
only b and c will be saved. a will not be saved because it does not change once the game begins.
o is not saved because it does not change – the object it refers to changes, but the variable itself does not.


## What isn't Savedlink
Python variables that are not changed after the game begins will not be saved. 
This can be a major problem if a variable that is not saved and one that is refer to the same object. 
(Alias the object.) In this example:
```
init python:
    a = object()
    a.f = 1

label start:
    $ b = a
    $ b.f = 2

    "a.f=[a.f] b.f=[b.f]"
```
a and b are aliased. Saving and loading may break this aliasing, causing a and b to refer to different objects. 
Since this can be very confusing, <strong>it's best to avoid aliasing saved and unsaved variables</strong>. 

There are several other kinds of state that isn't saved:
### 1. control flow path
Ren'Py only saves the current statement, and the statement it needs to return to. It doesn't remember how it got there. 
Importantly, statements (including variable assignments) that are added to the game won't run.

### 2. mappings of image names to displayables
Since this mapping is not saved, the image may change to a new image when the game loads again. 
This allows an image to change to a new file as the game evolves.

### 3. configuration variables, styles, and style properties
Configuration variables and styles aren't saved as part of the game. 
Therefore, they should only be changed in init blocks, and left alone once the game has started.

<br>

## save
在Ren'Py中，`renpy.save(filename, extra_info='')` 函数用于保存游戏的状态到指定的存档槽位。以下是该函数的基本使用方法：

```python
# 使用方式：
renpy.save(filename, extra_info='')

# 参数说明：
- filename: 字符串类型，给定存档槽位的名称。这个名称将会出现在游戏中存档列表里，玩家可以通过它来识别不同的存档点。
- extra_info: 可选字符串参数，允许您附加额外的信息到存档数据中。这可以是任何对存档有用的信息，比如当前章节名、时间戳或者其他元数据。

示例：
# 假设玩家在游戏中达到一个重要决策点，想要创建一个存档点
python:
    renpy.save("关键选择点_A")

# 或者附加上一些额外信息
python:
    chapter_name = "第一章：抉择时刻"
    renpy.save("重要分支_B", extra_info=chapter_name)

# 游戏中一般会在适当的交互点或剧情触发时调用此函数来保存游戏进度。
```
在Ren'Py游戏中，开发者通常不会直接在脚本中显式地调用 `renpy.save()`，而是在UI元素（如菜单选项或快捷键绑定）上设置动作（action），以便玩家在游戏过程中自行保存进度。不过，如果是自动存档或其他特殊逻辑需要时，可能会在游戏脚本中编写条件语句来调用保存功能。


`renpy.load(filename)` 函数用于加载之前保存的游戏状态。这个函数通常由游戏框架在后台自动调用，以实现读取存档并恢复玩家的游戏进度。
然而，由于安全性原因，通常不允许开发者在脚本中直接使用 renpy.load() 来篡改游戏状态或进行作弊行为。

如果玩家想从某个存档点继续游戏，他们会通过游戏菜单选择一个已有的存档文件，此时Ren'Py引擎会自动调用加载函数来恢复相关的游戏状态，
包括但不限于对话历史、变量值、位置信息和屏幕状态等。

<br>

## reference
https://www.renpy.org/doc/html/save_load_rollback.html